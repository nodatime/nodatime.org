<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <link href="prettify.css" type="text/css" rel="stylesheet" />
    <link href="styles.css" type="text/css" rel="stylesheet" />
    <script type="text/javascript" src="prettify.js"></script>
    <title>BCL Conversions</title>
  </head>
  <body onload="prettyPrint()">
    <h1>BCL Conversions</h1>
    <p>Various Noda Time types have "broadly similar" types in the .NET
framework's Base Class Library (BCL). Where appropriate,
conversions are provided - we have no illusions that you'll be able 
to use Noda Time for <em>everything</em>. Noda Time attempts to shield you
from using "the wrong kind of <code>DateTime</code>"</p>

<p>All BCL type conversions to Noda Time types which have implicit calendar systems (<code>LocalDateTime</code> etc) use
the ISO-8601 calendar.</p>

<h1>DateTime</h1>

<p><code>DateTime</code> can represent many things (which is <a href="http://noda-time.blogspot.com/2011/08/what-wrong-with-datetime-anyway.html">one of the reasons</a> Noda Time exists).</p>

<p>However, the following mappings are reasonable:</p>

<table>
  <thead>
    <tr>
      <td>Noda Time type</td>
      <td>DateTime kind</td>
      <td>Noda Time to BCL conversion</td>
      <td>BCL to Noda Time conversion</td>
      <td>Notes</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Instant</td>
      <td>Utc</td>
      <td>Instant.ToDateTimeUtc</td>
      <td>Instant.FromDateTimeUtc</td>
      <td></td>
    </tr>
    <tr>
      <td>ZonedDateTime</td>
      <td>Universal</td>
      <td>ZonedDateTime.ToDateTimeUtc</td>
      <td>n/a</td>
      <td>This preserves the instant, but loses the time zone information</td>
    </tr>
    <tr>
      <td>ZonedDateTime</td>
      <td>Unspecified</td>
      <td>ZonedDateTime.ToDateTimeUnspecified</td>
      <td>n/a</td>
      <td>This preserves the local time, but loses the time zone information</td>
    </tr>
    <tr>
      <td>LocalDateTime</td>
      <td>Unspecified</td>
      <td>LocalDateTime.ToDateTimeUnspecified</td>
      <td>LocalDateTime.FromDateTime</td>
      <td>FromDateTime uses the "local" value of the DateTime regardless of kind</td>
    </tr>
    <tr>
      <td>OffsetDateTime</td>
      <td>Unspecified</td>
      <td>OffsetDateTime.ToDateTimeOffset</td>
      <td>OffsetDateTime.FromDateTimeOffset</td>
      <td>FromDateTimeOffset uses the "local" value of the DateTime regardless of kind</td>
    </tr>
  </tbody>
</table>

<p>Note that there are no conversions to a <code>DateTime</code> with a kind of <code>Local</code> - this would effectively
be for the system default time zone, which you should generally be explicit about to start with.</p>

<h1>DateTimeOffset</h1>

<p><a href="../api/html/T_NodaTime_OffsetDateTime.htm"><code>OffsetDateTime</code></a> corresponds most closely to <code>DateTimeOffset</code>, although you can also use a <a href="../api/html/T_NodaTime_ZonedDateTime.htm"><code>ZonedDateTime</code></a> with a fixed time zone. That's exactly what <code>ZonedDateTime.FromDateTimeOffset</code> does,
but you must be aware that "real" time zone information is lost as soon as you've got a <code>DateTimeOffset</code> - 
it represents an exact instant in time, with a local offset from UTC, but that doesn't tell you what the
local offset would be a minute later or earlier. The reverse conversion (<code>ZonedDateTime.ToDateTimeOffset</code>)
loses the time zone information in a similar way.</p>

<p><code>Instant</code> also provides conversions to and from <code>DateTimeOffset</code>; <code>ToDateTimeOffset</code> will always return a
<code>DateTimeOffset</code> with an offset of zero, and <code>FromDateTimeOffset</code> will "subtract" the offset from local time,
to represent the appropriate instant in time - but without any further trace of the offset, which isn't stored in an <code>Instant</code>.</p>

<h1>TimeSpan</h1>

<p>Both <a href="../api/html/T_NodaTime_Offset.htm"><code>Offset</code></a> and <a href="../api/html/T_NodaTime_Duration.htm"><code>Duration</code></a> are similar to <code>TimeSpan</code>,
but they're used in different senses; <code>Offset</code> is used to indicate the difference between UTC and local time, whereas
a <code>Duration</code> is simply an arbitrary number of ticks.</p>

<p>Both types have <code>ToTimeSpan</code> and <code>FromTimeSpan</code> methods, although <code>Offset.FromTimeSpan</code> will throw an <code>ArgumentOutOfRangeException</code>
if the <code>TimeSpan</code> has a magnitude of 24 hours or more.</p>

<h1>TimeZoneInfo</h1>

<p>The main time zone type in Noda Time is <a href="../api/html/T_NodaTime_DateTimeZone.htm"><code>DateTimeZone</code></a>, which the default provider
creates from the zoneinfo time zone database. However, if you want to create a
<code>DateTimeZone</code> which corresponds exactly to a particular <code>TimeZoneInfo</code>,
there are some options using <a href="../api/html/T_NodaTime_TimeZones_BclDateTimeZone.htm"><code>BclDateTimeZone</code></a>:</p>

<ul>
<li>You can use <code>DateTimeZoneProviders.Bcl</code> everywhere you create time zones. (You may well want to inject this as an <a href="../api/html/T_NodaTime_IDateTimeZoneProvider.htm"><code>IDateTimeZoneProvider</code></a>
if you're using dependency injection). This is appropriate if you're going to work with various time zones,
and you only ever care about the BCL versions.</li>
<li>To convert a single time zone, you can use <code>BclDateTimeZone.FromTimeZoneInfo</code>.</li>
<li>If you just need the system default time zone, you can call
<code>BclDateTimeZone.ForSystemDefault</code>. There are some (rare) circumstances where
using <code>DateTimeZoneProviders.Tzdb.GetSystemDefault</code> may throw an exception,
indicating that there's no known mapping from the local BCL time zone ID to
TZDB. Using <code>BclDateTimeZone.ForSystemDefault()</code> <em>always</em> returns a converted
version of the BCL local time zone.</li>
</ul>

<p>There are various pros and cons involved in using the zoneinfo time
zones vs the BCL ones. In particular:</p>

<ul>
<li>If you need to interoperate with non-Windows systems, they're
likely to use the zoneinfo IDs</li>
<li>If you need to interoperate with Windows systems, they're likely
to use the Windows IDs</li>
<li>zoneinfo provides more historical information</li>
<li>If you're running Noda Time under Windows, changes to BCL time zone
information will become available automatically</li>
<li>Using the zoneinfo database allows you to decide exactly when you
update your time zone information (e.g. if you need to check that
all the zones still have the same IDs, or even to find zones which
have changed in a meaningful way for your data)</li>
</ul>

<h1>DayOfWeek</h1>

<p>For every day other than Sunday, <code>DayOfWeek</code> and
<a href="../api/html/T_NodaTime_IsoDayOfWeek.htm"><code>IsoDayOfWeek</code></a> have the same
value. However, <code>DayOfWeek</code> uses 0 for Sunday, and <code>IsoDayOfWeek</code>
uses 7 (as per ISO-8601). Converting between the two isn't
difficult, but there are utility methods in
<a href="../api/html/T_NodaTime_Utility_BclConversions.htm"><code>BclConversions</code></a> to
make things slightly smoother:</p>

<pre class="prettyprint"><code>DayOfWeek bcl = BclConversions.ToDayOfWeek(IsoDayOfWeek.Wednesday);
IsoDayOfWeek iso = BclConversions.ToIsoDayOfWeek(DayOfWeek.Wednesday);
</code></pre>

<h1>Any others?</h1>

<p>If you have other requirements around BCL conversions, please ask on
the <a href="http://groups.google.com/group/noda-time">mailing list</a>.</p>

  </body>
</html>
