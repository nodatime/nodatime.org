using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;

namespace DocfxNullableReferenceFixer
{
    /// <summary>
    /// Quick and hacky way to fix up YAML files generated by docfx before it supports nullable
    /// reference types properly. Anywhere we see System.Nullable{T} but know that T is a reference
    /// type, we replace it with T.
    /// </summary>
    class Program
    {
        // It's simpler to handle non-generic types and generic types in separate regexes. We still don't handle generic types
        // with generic type arguments, but hey...
        // (We also hope that we don't have any types that are only in angle brackets.)
        private static readonly Regex NonGenericPattern = new Regex(@"System\.Nullable\{(?<type>[^{}]+)\}");
        private static readonly Regex GenericPattern = new Regex(@"System\.Nullable\{(?<type>[^{]+\{[^{}]+\})\}");

        private static readonly string[] KnownReferenceTypes =
        {
            // It's simpler to list the concrete type than just the generic type - it makes replacement simpler.
            "System.Collections.Generic.IList{NodaTime.TimeZones.TzdbZone1970Location}",
            "System.Collections.Generic.IList{NodaTime.TimeZones.TzdbZoneLocation}",
            "System.String",
            "System.Object",
            "System.IFormatProvider",
            "NodaTime.DateInterval",
            "NodaTime.Period",
            "NodaTime.DateTimeZone",
            "NodaTime.TimeZones.Cldr.MapZone",
            "NodaTime.TimeZones.ZoneLocalMappingResolver",
            "NodaTime.TimeZones.TzdbZone1970Location.Country",
            "NodaTime.TimeZones.ZoneInterval",
            "NodaTime.IDateTimeZoneProvider",
        };

        private static readonly string[] KnownValueTypes =
        {
            "NodaTime.Instant"
        };

        private static int Main(string[] args)
        {
            if (args.Length != 2 || (args[0] != "--show" && args[0] != "--fix"))
            {
                Console.WriteLine($"Arguments: (--show|--fix) <directory>");
                return 1;
            }
            var action = args[0] == "--fix" ? (Action<string>) FixReferences : ShowReferences;
            foreach (var file in Directory.GetFiles(args[1], "*.yml"))
            {
                action(file);
            }
            return 0;
        }

        private static void FixReferences(string file)
        {
            var outputLines = new List<string>();
            var inputLines = File.ReadAllLines(file);
            var skipping = false;
            foreach (var line in inputLines)
            {                
                if (line.StartsWith("- uid: "))
                {
                    if (line.StartsWith("- uid: System.Nullable{") && KnownReferenceTypes.Any(krt => line.StartsWith($"- uid: System.Nullable{{{krt}")))
                    {
                        skipping = true;
                    }
                    else
                    {
                        skipping = false;
                    }
                }
                if (skipping)
                {
                    continue;
                }
                // We won't do the right thing with generics here, but this whole program is only a temporary hack
                // until docfx supports C# 8 anyway - there's a single class (TzdbDateTimeZoneSource) that would
                // be affected. I'm okay with that...
                string resultLine = line;
                foreach (var type in KnownReferenceTypes)
                {
                    string shortName = type.Split('.').Last();
                    resultLine = resultLine
                        .Replace($"System.Nullable{{{type}}}", type)
                        .Replace($"System.Nullable<{type}>", type)
                        .Replace($"System.Nullable.Of({type}", type)
                        .Replace($"Nullable.Of({shortName}", shortName)
                        .Replace($"Nullable<{shortName}>", shortName);
                }
                outputLines.Add(resultLine);
            }
            File.WriteAllLines(file, outputLines);
        }

        private static void ShowReferences(string file)
        {
            string text = File.ReadAllText(file);
            var types = NonGenericPattern.Matches(text).Cast<Match>()
                .Concat(GenericPattern.Matches(text).Cast<Match>())
                .Select(m => m.Groups["type"].Value)
                .Distinct()
                .Except(KnownReferenceTypes)
                .Except(KnownValueTypes)
                .OrderBy(t => t)
                .ToList();
            if (types.Count != 0)
            {
                Console.WriteLine($"{Path.GetFileName(file)}: {string.Join(", ", types)}");
            }
        }
    }
}
